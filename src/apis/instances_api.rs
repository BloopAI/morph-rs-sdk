/*
 * MorphVM API
 *
 * REST API for managing MorphVM instances and snapshots.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`boot_instance_snapshot_snapshot_id_boot_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BootInstanceSnapshotSnapshotIdBootPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`branch_instance_instance_instance_id_branch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BranchInstanceInstanceInstanceIdBranchPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`exec_instance_instance_id_exec_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecInstanceInstanceIdExecPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`expose_http_service_instance_instance_id_http_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExposeHttpServiceInstanceInstanceIdHttpPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_instance_instance_instance_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInstanceInstanceInstanceIdGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_ssh_key_instance_instance_id_ssh_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSshKeyInstanceInstanceIdSshKeyGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hide_http_service_instance_instance_id_http_service_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HideHttpServiceInstanceInstanceIdHttpServiceNameDeleteError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_instances_instance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListInstancesInstanceGetError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pause_instance_instance_instance_id_pause_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PauseInstanceInstanceInstanceIdPausePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reboot_instance_instance_instance_id_reboot_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RebootInstanceInstanceInstanceIdRebootPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resume_instance_instance_instance_id_resume_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResumeInstanceInstanceInstanceIdResumePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rotate_ssh_key_instance_instance_id_ssh_key_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RotateSshKeyInstanceInstanceIdSshKeyPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_instance_metadata_instance_instance_id_metadata_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetInstanceMetadataInstanceInstanceIdMetadataPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`snapshot_instance_instance_instance_id_snapshot_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SnapshotInstanceInstanceInstanceIdSnapshotPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_instance_instance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartInstanceInstancePostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_instance_instance_instance_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopInstanceInstanceInstanceIdDeleteError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_instance_ttl_instance_instance_id_ttl_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInstanceTtlInstanceInstanceIdTtlPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_instance_wake_on_instance_instance_id_wake_on_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateInstanceWakeOnInstanceInstanceIdWakeOnPostError {
    Status422(models::HttpValidationError),
    UnknownValue(serde_json::Value),
}


/// Boot an instance from a snapshot.
pub async fn boot_instance_snapshot_snapshot_id_boot_post(configuration: &configuration::Configuration, snapshot_id: &str, boot_instance_request: models::BootInstanceRequest) -> Result<models::InstanceModel, Error<BootInstanceSnapshotSnapshotIdBootPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_snapshot_id = snapshot_id;
    let p_boot_instance_request = boot_instance_request;

    let uri_str = format!("{}/snapshot/{snapshot_id}/boot", configuration.base_path, snapshot_id=crate::apis::urlencode(p_snapshot_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_boot_instance_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BootInstanceSnapshotSnapshotIdBootPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Branch an instance into multiple instances creating a new snapshot.
pub async fn branch_instance_instance_instance_id_branch_post(configuration: &configuration::Configuration, instance_id: &str, count: Option<i32>, digest: Option<&str>, branch_instance_request: Option<models::BranchInstanceRequest>) -> Result<models::BranchInstanceResponse, Error<BranchInstanceInstanceInstanceIdBranchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_count = count;
    let p_digest = digest;
    let p_branch_instance_request = branch_instance_request;

    let uri_str = format!("{}/instance/{instance_id}/branch", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_digest {
        req_builder = req_builder.query(&[("digest", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_branch_instance_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BranchInstanceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BranchInstanceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BranchInstanceInstanceInstanceIdBranchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a shell command inside a VM via SSH (AsyncSSH backend).
pub async fn exec_instance_instance_id_exec_post(configuration: &configuration::Configuration, instance_id: &str, exec_request: models::ExecRequest) -> Result<models::ExecResponse, Error<ExecInstanceInstanceIdExecPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_exec_request = exec_request;

    let uri_str = format!("{}/instance/{instance_id}/exec", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_exec_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExecResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExecResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecInstanceInstanceIdExecPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Expose an HTTP service on an instance.
pub async fn expose_http_service_instance_instance_id_http_post(configuration: &configuration::Configuration, instance_id: &str, expose_http_service_request: models::ExposeHttpServiceRequest) -> Result<models::InstanceModel, Error<ExposeHttpServiceInstanceInstanceIdHttpPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_expose_http_service_request = expose_http_service_request;

    let uri_str = format!("{}/instance/{instance_id}/http", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_expose_http_service_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExposeHttpServiceInstanceInstanceIdHttpPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get an instance by ID.
pub async fn get_instance_instance_instance_id_get(configuration: &configuration::Configuration, instance_id: &str) -> Result<models::InstanceModel, Error<GetInstanceInstanceInstanceIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;

    let uri_str = format!("{}/instance/{instance_id}", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInstanceInstanceInstanceIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the SSH key pair for an instance.
pub async fn get_ssh_key_instance_instance_id_ssh_key_get(configuration: &configuration::Configuration, instance_id: &str) -> Result<models::InstanceSshKey, Error<GetSshKeyInstanceInstanceIdSshKeyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;

    let uri_str = format!("{}/instance/{instance_id}/ssh/key", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceSshKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceSshKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSshKeyInstanceInstanceIdSshKeyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Hide an HTTP service on an instance.
pub async fn hide_http_service_instance_instance_id_http_service_name_delete(configuration: &configuration::Configuration, instance_id: &str, service_name: &str) -> Result<models::InstanceModel, Error<HideHttpServiceInstanceInstanceIdHttpServiceNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_service_name = service_name;

    let uri_str = format!("{}/instance/{instance_id}/http/{service_name}", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id), service_name=crate::apis::urlencode(p_service_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HideHttpServiceInstanceInstanceIdHttpServiceNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List instances.
pub async fn list_instances_instance_get(configuration: &configuration::Configuration, metadata: Option<std::collections::HashMap<String, String>>) -> Result<models::InstanceModelCollection, Error<ListInstancesInstanceGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_metadata = metadata;

    let uri_str = format!("{}/instance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_metadata {
        let mut query_params = Vec::with_capacity(param_value.len());
        for (key, value) in param_value.iter() {
            query_params.push((key.to_string(), serde_json::to_string(value)?));
        }
        req_builder = req_builder.query(&query_params);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModelCollection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModelCollection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListInstancesInstanceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Pause an instance.
pub async fn pause_instance_instance_instance_id_pause_post(configuration: &configuration::Configuration, instance_id: &str, no_snapshot: Option<bool>) -> Result<models::InstanceModel, Error<PauseInstanceInstanceInstanceIdPausePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_no_snapshot = no_snapshot;

    let uri_str = format!("{}/instance/{instance_id}/pause", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_no_snapshot {
        req_builder = req_builder.query(&[("no_snapshot", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PauseInstanceInstanceInstanceIdPausePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restart an instance.
pub async fn reboot_instance_instance_instance_id_reboot_post(configuration: &configuration::Configuration, instance_id: &str) -> Result<models::InstanceModel, Error<RebootInstanceInstanceInstanceIdRebootPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;

    let uri_str = format!("{}/instance/{instance_id}/reboot", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RebootInstanceInstanceInstanceIdRebootPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Resume a paused instance.
pub async fn resume_instance_instance_instance_id_resume_post(configuration: &configuration::Configuration, instance_id: &str) -> Result<models::InstanceModel, Error<ResumeInstanceInstanceInstanceIdResumePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;

    let uri_str = format!("{}/instance/{instance_id}/resume", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResumeInstanceInstanceInstanceIdResumePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Rotate the SSH key pair for an instance.
pub async fn rotate_ssh_key_instance_instance_id_ssh_key_post(configuration: &configuration::Configuration, instance_id: &str) -> Result<models::InstanceSshKey, Error<RotateSshKeyInstanceInstanceIdSshKeyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;

    let uri_str = format!("{}/instance/{instance_id}/ssh/key", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceSshKey`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceSshKey`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RotateSshKeyInstanceInstanceIdSshKeyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set metadata for an instance.
pub async fn set_instance_metadata_instance_instance_id_metadata_post(configuration: &configuration::Configuration, instance_id: &str, request_body: std::collections::HashMap<String, String>) -> Result<models::InstanceModel, Error<SetInstanceMetadataInstanceInstanceIdMetadataPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_request_body = request_body;

    let uri_str = format!("{}/instance/{instance_id}/metadata", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetInstanceMetadataInstanceInstanceIdMetadataPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a snapshot from an instance.
pub async fn snapshot_instance_instance_instance_id_snapshot_post(configuration: &configuration::Configuration, instance_id: &str, digest: Option<&str>, snapshot_instance_request: Option<models::SnapshotInstanceRequest>) -> Result<models::SnapshotModel, Error<SnapshotInstanceInstanceInstanceIdSnapshotPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_digest = digest;
    let p_snapshot_instance_request = snapshot_instance_request;

    let uri_str = format!("{}/instance/{instance_id}/snapshot", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_digest {
        req_builder = req_builder.query(&[("digest", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_snapshot_instance_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SnapshotModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SnapshotModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SnapshotInstanceInstanceInstanceIdSnapshotPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a new instance from a snapshot.
pub async fn start_instance_instance_post(configuration: &configuration::Configuration, snapshot_id: &str, start_instance_request: Option<models::StartInstanceRequest>) -> Result<models::InstanceModel, Error<StartInstanceInstancePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_snapshot_id = snapshot_id;
    let p_start_instance_request = start_instance_request;

    let uri_str = format!("{}/instance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("snapshot_id", &p_snapshot_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_start_instance_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartInstanceInstancePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Stop and delete an instance by ID.
pub async fn stop_instance_instance_instance_id_delete(configuration: &configuration::Configuration, instance_id: &str) -> Result<(), Error<StopInstanceInstanceInstanceIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;

    let uri_str = format!("{}/instance/{instance_id}", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StopInstanceInstanceInstanceIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the TTL (Time To Live) for an instance.
pub async fn update_instance_ttl_instance_instance_id_ttl_post(configuration: &configuration::Configuration, instance_id: &str, update_ttl_request: models::UpdateTtlRequest) -> Result<models::InstanceModel, Error<UpdateInstanceTtlInstanceInstanceIdTtlPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_update_ttl_request = update_ttl_request;

    let uri_str = format!("{}/instance/{instance_id}/ttl", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_ttl_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateInstanceTtlInstanceInstanceIdTtlPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the wake-on-request settings for an instance.
pub async fn update_instance_wake_on_instance_instance_id_wake_on_post(configuration: &configuration::Configuration, instance_id: &str, update_wake_request: models::UpdateWakeRequest) -> Result<models::InstanceModel, Error<UpdateInstanceWakeOnInstanceInstanceIdWakeOnPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_instance_id = instance_id;
    let p_update_wake_request = update_wake_request;

    let uri_str = format!("{}/instance/{instance_id}/wake-on", configuration.base_path, instance_id=crate::apis::urlencode(p_instance_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_wake_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InstanceModel`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InstanceModel`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateInstanceWakeOnInstanceInstanceIdWakeOnPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

